// Code generated by Prisma (prisma@1.25.4). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  blockchain: (where?: BlockchainWhereInput) => Promise<boolean>;
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  game: (where?: GameWhereInput) => Promise<boolean>;
  genre: (where?: GenreWhereInput) => Promise<boolean>;
  image: (where?: ImageWhereInput) => Promise<boolean>;
  seo: (where?: SeoWhereInput) => Promise<boolean>;
  social: (where?: SocialWhereInput) => Promise<boolean>;
  statistic: (where?: StatisticWhereInput) => Promise<boolean>;
  topApp: (where?: TopAppWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  blockchain: (where: BlockchainWhereUniqueInput) => BlockchainPromise;
  blockchains: (args?: {
    where?: BlockchainWhereInput;
    orderBy?: BlockchainOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Blockchain>;
  blockchainsConnection: (args?: {
    where?: BlockchainWhereInput;
    orderBy?: BlockchainOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BlockchainConnectionPromise;
  category: (where: CategoryWhereUniqueInput) => CategoryPromise;
  categories: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Category>;
  categoriesConnection: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CategoryConnectionPromise;
  game: (where: GameWhereUniqueInput) => GamePromise;
  games: (args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Game>;
  gamesConnection: (args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GameConnectionPromise;
  genre: (where: GenreWhereUniqueInput) => GenrePromise;
  genres: (args?: {
    where?: GenreWhereInput;
    orderBy?: GenreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Genre>;
  genresConnection: (args?: {
    where?: GenreWhereInput;
    orderBy?: GenreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GenreConnectionPromise;
  image: (where: ImageWhereUniqueInput) => ImagePromise;
  images: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Image>;
  imagesConnection: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ImageConnectionPromise;
  seo: (where: SeoWhereUniqueInput) => SeoPromise;
  seos: (args?: {
    where?: SeoWhereInput;
    orderBy?: SeoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Seo>;
  seosConnection: (args?: {
    where?: SeoWhereInput;
    orderBy?: SeoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SeoConnectionPromise;
  social: (where: SocialWhereUniqueInput) => SocialPromise;
  socials: (args?: {
    where?: SocialWhereInput;
    orderBy?: SocialOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Social>;
  socialsConnection: (args?: {
    where?: SocialWhereInput;
    orderBy?: SocialOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SocialConnectionPromise;
  statistic: (where: StatisticWhereUniqueInput) => StatisticPromise;
  statistics: (args?: {
    where?: StatisticWhereInput;
    orderBy?: StatisticOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Statistic>;
  statisticsConnection: (args?: {
    where?: StatisticWhereInput;
    orderBy?: StatisticOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StatisticConnectionPromise;
  topApp: (where: TopAppWhereUniqueInput) => TopAppPromise;
  topApps: (args?: {
    where?: TopAppWhereInput;
    orderBy?: TopAppOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TopApp>;
  topAppsConnection: (args?: {
    where?: TopAppWhereInput;
    orderBy?: TopAppOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TopAppConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBlockchain: (data: BlockchainCreateInput) => BlockchainPromise;
  updateBlockchain: (args: {
    data: BlockchainUpdateInput;
    where: BlockchainWhereUniqueInput;
  }) => BlockchainPromise;
  updateManyBlockchains: (args: {
    data: BlockchainUpdateManyMutationInput;
    where?: BlockchainWhereInput;
  }) => BatchPayloadPromise;
  upsertBlockchain: (args: {
    where: BlockchainWhereUniqueInput;
    create: BlockchainCreateInput;
    update: BlockchainUpdateInput;
  }) => BlockchainPromise;
  deleteBlockchain: (where: BlockchainWhereUniqueInput) => BlockchainPromise;
  deleteManyBlockchains: (where?: BlockchainWhereInput) => BatchPayloadPromise;
  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (args: {
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
  }) => CategoryPromise;
  updateManyCategories: (args: {
    data: CategoryUpdateManyMutationInput;
    where?: CategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertCategory: (args: {
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
  }) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createGame: (data: GameCreateInput) => GamePromise;
  updateGame: (args: {
    data: GameUpdateInput;
    where: GameWhereUniqueInput;
  }) => GamePromise;
  updateManyGames: (args: {
    data: GameUpdateManyMutationInput;
    where?: GameWhereInput;
  }) => BatchPayloadPromise;
  upsertGame: (args: {
    where: GameWhereUniqueInput;
    create: GameCreateInput;
    update: GameUpdateInput;
  }) => GamePromise;
  deleteGame: (where: GameWhereUniqueInput) => GamePromise;
  deleteManyGames: (where?: GameWhereInput) => BatchPayloadPromise;
  createGenre: (data: GenreCreateInput) => GenrePromise;
  updateGenre: (args: {
    data: GenreUpdateInput;
    where: GenreWhereUniqueInput;
  }) => GenrePromise;
  updateManyGenres: (args: {
    data: GenreUpdateManyMutationInput;
    where?: GenreWhereInput;
  }) => BatchPayloadPromise;
  upsertGenre: (args: {
    where: GenreWhereUniqueInput;
    create: GenreCreateInput;
    update: GenreUpdateInput;
  }) => GenrePromise;
  deleteGenre: (where: GenreWhereUniqueInput) => GenrePromise;
  deleteManyGenres: (where?: GenreWhereInput) => BatchPayloadPromise;
  createImage: (data: ImageCreateInput) => ImagePromise;
  updateImage: (args: {
    data: ImageUpdateInput;
    where: ImageWhereUniqueInput;
  }) => ImagePromise;
  updateManyImages: (args: {
    data: ImageUpdateManyMutationInput;
    where?: ImageWhereInput;
  }) => BatchPayloadPromise;
  upsertImage: (args: {
    where: ImageWhereUniqueInput;
    create: ImageCreateInput;
    update: ImageUpdateInput;
  }) => ImagePromise;
  deleteImage: (where: ImageWhereUniqueInput) => ImagePromise;
  deleteManyImages: (where?: ImageWhereInput) => BatchPayloadPromise;
  createSeo: (data: SeoCreateInput) => SeoPromise;
  updateSeo: (args: {
    data: SeoUpdateInput;
    where: SeoWhereUniqueInput;
  }) => SeoPromise;
  updateManySeos: (args: {
    data: SeoUpdateManyMutationInput;
    where?: SeoWhereInput;
  }) => BatchPayloadPromise;
  upsertSeo: (args: {
    where: SeoWhereUniqueInput;
    create: SeoCreateInput;
    update: SeoUpdateInput;
  }) => SeoPromise;
  deleteSeo: (where: SeoWhereUniqueInput) => SeoPromise;
  deleteManySeos: (where?: SeoWhereInput) => BatchPayloadPromise;
  createSocial: (data: SocialCreateInput) => SocialPromise;
  updateSocial: (args: {
    data: SocialUpdateInput;
    where: SocialWhereUniqueInput;
  }) => SocialPromise;
  updateManySocials: (args: {
    data: SocialUpdateManyMutationInput;
    where?: SocialWhereInput;
  }) => BatchPayloadPromise;
  upsertSocial: (args: {
    where: SocialWhereUniqueInput;
    create: SocialCreateInput;
    update: SocialUpdateInput;
  }) => SocialPromise;
  deleteSocial: (where: SocialWhereUniqueInput) => SocialPromise;
  deleteManySocials: (where?: SocialWhereInput) => BatchPayloadPromise;
  createStatistic: (data: StatisticCreateInput) => StatisticPromise;
  updateStatistic: (args: {
    data: StatisticUpdateInput;
    where: StatisticWhereUniqueInput;
  }) => StatisticPromise;
  updateManyStatistics: (args: {
    data: StatisticUpdateManyMutationInput;
    where?: StatisticWhereInput;
  }) => BatchPayloadPromise;
  upsertStatistic: (args: {
    where: StatisticWhereUniqueInput;
    create: StatisticCreateInput;
    update: StatisticUpdateInput;
  }) => StatisticPromise;
  deleteStatistic: (where: StatisticWhereUniqueInput) => StatisticPromise;
  deleteManyStatistics: (where?: StatisticWhereInput) => BatchPayloadPromise;
  createTopApp: (data: TopAppCreateInput) => TopAppPromise;
  updateTopApp: (args: {
    data: TopAppUpdateInput;
    where: TopAppWhereUniqueInput;
  }) => TopAppPromise;
  updateManyTopApps: (args: {
    data: TopAppUpdateManyMutationInput;
    where?: TopAppWhereInput;
  }) => BatchPayloadPromise;
  upsertTopApp: (args: {
    where: TopAppWhereUniqueInput;
    create: TopAppCreateInput;
    update: TopAppUpdateInput;
  }) => TopAppPromise;
  deleteTopApp: (where: TopAppWhereUniqueInput) => TopAppPromise;
  deleteManyTopApps: (where?: TopAppWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  blockchain: (
    where?: BlockchainSubscriptionWhereInput
  ) => BlockchainSubscriptionPayloadSubscription;
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  game: (
    where?: GameSubscriptionWhereInput
  ) => GameSubscriptionPayloadSubscription;
  genre: (
    where?: GenreSubscriptionWhereInput
  ) => GenreSubscriptionPayloadSubscription;
  image: (
    where?: ImageSubscriptionWhereInput
  ) => ImageSubscriptionPayloadSubscription;
  seo: (
    where?: SeoSubscriptionWhereInput
  ) => SeoSubscriptionPayloadSubscription;
  social: (
    where?: SocialSubscriptionWhereInput
  ) => SocialSubscriptionPayloadSubscription;
  statistic: (
    where?: StatisticSubscriptionWhereInput
  ) => StatisticSubscriptionPayloadSubscription;
  topApp: (
    where?: TopAppSubscriptionWhereInput
  ) => TopAppSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type SocialOrderByInput =
  | "link_ASC"
  | "link_DESC"
  | "name_ASC"
  | "name_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CategoryOrderByInput =
  | "name_ASC"
  | "name_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GenreOrderByInput =
  | "name_ASC"
  | "name_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TopAppLayoutType = "MAIN" | "SHORTENED" | "EXTENDED";

export type StatisticOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "timestamp_ASC"
  | "timestamp_DESC"
  | "dailyPlayers_ASC"
  | "dailyPlayers_DESC"
  | "transactions_ASC"
  | "transactions_DESC"
  | "volume_ASC"
  | "volume_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ImageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "link_ASC"
  | "link_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type GameOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "excerpt_ASC"
  | "excerpt_DESC"
  | "description_ASC"
  | "description_DESC"
  | "mounthslyPlayers_ASC"
  | "mounthslyPlayers_DESC"
  | "featured_ASC"
  | "featured_DESC"
  | "importId_ASC"
  | "importId_DESC"
  | "created_ASC"
  | "created_DESC"
  | "link_ASC"
  | "link_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SeoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "keywords_ASC"
  | "keywords_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BlockchainOrderByInput =
  | "name_ASC"
  | "name_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TopAppOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "position_ASC"
  | "position_DESC"
  | "layout_ASC"
  | "layout_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface BlockchainUpdateManyInput {
  create?: BlockchainCreateInput[] | BlockchainCreateInput;
  update?:
    | BlockchainUpdateWithWhereUniqueNestedInput[]
    | BlockchainUpdateWithWhereUniqueNestedInput;
  upsert?:
    | BlockchainUpsertWithWhereUniqueNestedInput[]
    | BlockchainUpsertWithWhereUniqueNestedInput;
  delete?: BlockchainWhereUniqueInput[] | BlockchainWhereUniqueInput;
  connect?: BlockchainWhereUniqueInput[] | BlockchainWhereUniqueInput;
  disconnect?: BlockchainWhereUniqueInput[] | BlockchainWhereUniqueInput;
  deleteMany?: BlockchainScalarWhereInput[] | BlockchainScalarWhereInput;
  updateMany?:
    | BlockchainUpdateManyWithWhereNestedInput[]
    | BlockchainUpdateManyWithWhereNestedInput;
}

export type BlockchainWhereUniqueInput = AtLeastOne<{
  name: String;
}>;

export interface BlockchainUpdateManyDataInput {
  name?: String;
}

export interface CategoryWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: CategoryWhereInput[] | CategoryWhereInput;
  OR?: CategoryWhereInput[] | CategoryWhereInput;
  NOT?: CategoryWhereInput[] | CategoryWhereInput;
}

export interface GenreCreateInput {
  name: String;
}

export interface GameUpsertWithoutImagesInput {
  update: GameUpdateWithoutImagesDataInput;
  create: GameCreateWithoutImagesInput;
}

export interface BlockchainCreateManyInput {
  create?: BlockchainCreateInput[] | BlockchainCreateInput;
  connect?: BlockchainWhereUniqueInput[] | BlockchainWhereUniqueInput;
}

export interface StatisticUpdateManyWithoutGameInput {
  create?: StatisticCreateWithoutGameInput[] | StatisticCreateWithoutGameInput;
  delete?: StatisticWhereUniqueInput[] | StatisticWhereUniqueInput;
  connect?: StatisticWhereUniqueInput[] | StatisticWhereUniqueInput;
  disconnect?: StatisticWhereUniqueInput[] | StatisticWhereUniqueInput;
  update?:
    | StatisticUpdateWithWhereUniqueWithoutGameInput[]
    | StatisticUpdateWithWhereUniqueWithoutGameInput;
  upsert?:
    | StatisticUpsertWithWhereUniqueWithoutGameInput[]
    | StatisticUpsertWithWhereUniqueWithoutGameInput;
  deleteMany?: StatisticScalarWhereInput[] | StatisticScalarWhereInput;
  updateMany?:
    | StatisticUpdateManyWithWhereNestedInput[]
    | StatisticUpdateManyWithWhereNestedInput;
}

export interface StatisticCreateManyWithoutGameInput {
  create?: StatisticCreateWithoutGameInput[] | StatisticCreateWithoutGameInput;
  connect?: StatisticWhereUniqueInput[] | StatisticWhereUniqueInput;
}

export type GameWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  importId?: ID_Input;
}>;

export interface StatisticCreateWithoutGameInput {
  timestamp: Float;
  dailyPlayers: Float;
  transactions: Float;
  volume: Float;
}

export interface SocialSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SocialWhereInput;
  AND?: SocialSubscriptionWhereInput[] | SocialSubscriptionWhereInput;
  OR?: SocialSubscriptionWhereInput[] | SocialSubscriptionWhereInput;
  NOT?: SocialSubscriptionWhereInput[] | SocialSubscriptionWhereInput;
}

export interface ImageCreateManyWithoutGameInput {
  create?: ImageCreateWithoutGameInput[] | ImageCreateWithoutGameInput;
  connect?: ImageWhereUniqueInput[] | ImageWhereUniqueInput;
}

export interface GenreWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: GenreWhereInput[] | GenreWhereInput;
  OR?: GenreWhereInput[] | GenreWhereInput;
  NOT?: GenreWhereInput[] | GenreWhereInput;
}

export interface ImageCreateWithoutGameInput {
  type: String;
  link: String;
}

export interface ImageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ImageWhereInput;
  AND?: ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput;
  OR?: ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput;
  NOT?: ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput;
}

export interface SocialCreateManyWithoutGameInput {
  create?: SocialCreateWithoutGameInput[] | SocialCreateWithoutGameInput;
  connect?: SocialWhereUniqueInput[] | SocialWhereUniqueInput;
}

export interface GameWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  category?: CategoryWhereInput;
  excerpt?: String;
  excerpt_not?: String;
  excerpt_in?: String[] | String;
  excerpt_not_in?: String[] | String;
  excerpt_lt?: String;
  excerpt_lte?: String;
  excerpt_gt?: String;
  excerpt_gte?: String;
  excerpt_contains?: String;
  excerpt_not_contains?: String;
  excerpt_starts_with?: String;
  excerpt_not_starts_with?: String;
  excerpt_ends_with?: String;
  excerpt_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  mounthslyPlayers?: Float;
  mounthslyPlayers_not?: Float;
  mounthslyPlayers_in?: Float[] | Float;
  mounthslyPlayers_not_in?: Float[] | Float;
  mounthslyPlayers_lt?: Float;
  mounthslyPlayers_lte?: Float;
  mounthslyPlayers_gt?: Float;
  mounthslyPlayers_gte?: Float;
  featured?: Boolean;
  featured_not?: Boolean;
  genres_every?: GenreWhereInput;
  genres_some?: GenreWhereInput;
  genres_none?: GenreWhereInput;
  blockchains_every?: BlockchainWhereInput;
  blockchains_some?: BlockchainWhereInput;
  blockchains_none?: BlockchainWhereInput;
  statistics_every?: StatisticWhereInput;
  statistics_some?: StatisticWhereInput;
  statistics_none?: StatisticWhereInput;
  images_every?: ImageWhereInput;
  images_some?: ImageWhereInput;
  images_none?: ImageWhereInput;
  socials_every?: SocialWhereInput;
  socials_some?: SocialWhereInput;
  socials_none?: SocialWhereInput;
  seo?: SeoWhereInput;
  topApp?: TopAppWhereInput;
  importId?: ID_Input;
  importId_not?: ID_Input;
  importId_in?: ID_Input[] | ID_Input;
  importId_not_in?: ID_Input[] | ID_Input;
  importId_lt?: ID_Input;
  importId_lte?: ID_Input;
  importId_gt?: ID_Input;
  importId_gte?: ID_Input;
  importId_contains?: ID_Input;
  importId_not_contains?: ID_Input;
  importId_starts_with?: ID_Input;
  importId_not_starts_with?: ID_Input;
  importId_ends_with?: ID_Input;
  importId_not_ends_with?: ID_Input;
  created?: Float;
  created_not?: Float;
  created_in?: Float[] | Float;
  created_not_in?: Float[] | Float;
  created_lt?: Float;
  created_lte?: Float;
  created_gt?: Float;
  created_gte?: Float;
  link?: String;
  link_not?: String;
  link_in?: String[] | String;
  link_not_in?: String[] | String;
  link_lt?: String;
  link_lte?: String;
  link_gt?: String;
  link_gte?: String;
  link_contains?: String;
  link_not_contains?: String;
  link_starts_with?: String;
  link_not_starts_with?: String;
  link_ends_with?: String;
  link_not_ends_with?: String;
  AND?: GameWhereInput[] | GameWhereInput;
  OR?: GameWhereInput[] | GameWhereInput;
  NOT?: GameWhereInput[] | GameWhereInput;
}

export interface SocialCreateWithoutGameInput {
  link: String;
  name: String;
}

export interface SocialWhereInput {
  game?: GameWhereInput;
  link?: String;
  link_not?: String;
  link_in?: String[] | String;
  link_not_in?: String[] | String;
  link_lt?: String;
  link_lte?: String;
  link_gt?: String;
  link_gte?: String;
  link_contains?: String;
  link_not_contains?: String;
  link_starts_with?: String;
  link_not_starts_with?: String;
  link_ends_with?: String;
  link_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: SocialWhereInput[] | SocialWhereInput;
  OR?: SocialWhereInput[] | SocialWhereInput;
  NOT?: SocialWhereInput[] | SocialWhereInput;
}

export interface SeoCreateOneWithoutGameInput {
  create?: SeoCreateWithoutGameInput;
  connect?: SeoWhereUniqueInput;
}

export interface TopAppWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  game?: GameWhereInput;
  category?: CategoryWhereInput;
  position?: Int;
  position_not?: Int;
  position_in?: Int[] | Int;
  position_not_in?: Int[] | Int;
  position_lt?: Int;
  position_lte?: Int;
  position_gt?: Int;
  position_gte?: Int;
  layout?: TopAppLayoutType;
  layout_not?: TopAppLayoutType;
  layout_in?: TopAppLayoutType[] | TopAppLayoutType;
  layout_not_in?: TopAppLayoutType[] | TopAppLayoutType;
  AND?: TopAppWhereInput[] | TopAppWhereInput;
  OR?: TopAppWhereInput[] | TopAppWhereInput;
  NOT?: TopAppWhereInput[] | TopAppWhereInput;
}

export interface SeoCreateWithoutGameInput {
  keywords: String;
  description: String;
}

export interface GameSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GameWhereInput;
  AND?: GameSubscriptionWhereInput[] | GameSubscriptionWhereInput;
  OR?: GameSubscriptionWhereInput[] | GameSubscriptionWhereInput;
  NOT?: GameSubscriptionWhereInput[] | GameSubscriptionWhereInput;
}

export interface TopAppCreateOneWithoutGameInput {
  create?: TopAppCreateWithoutGameInput;
  connect?: TopAppWhereUniqueInput;
}

export interface BlockchainSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BlockchainWhereInput;
  AND?: BlockchainSubscriptionWhereInput[] | BlockchainSubscriptionWhereInput;
  OR?: BlockchainSubscriptionWhereInput[] | BlockchainSubscriptionWhereInput;
  NOT?: BlockchainSubscriptionWhereInput[] | BlockchainSubscriptionWhereInput;
}

export interface TopAppCreateWithoutGameInput {
  category: CategoryCreateOneInput;
  position: Int;
  layout: TopAppLayoutType;
}

export interface GameUpsertWithoutTopAppInput {
  update: GameUpdateWithoutTopAppDataInput;
  create: GameCreateWithoutTopAppInput;
}

export interface GameUpdateInput {
  name?: String;
  category?: CategoryUpdateOneRequiredInput;
  excerpt?: String;
  description?: String;
  mounthslyPlayers?: Float;
  featured?: Boolean;
  genres?: GenreUpdateManyInput;
  blockchains?: BlockchainUpdateManyInput;
  statistics?: StatisticUpdateManyWithoutGameInput;
  images?: ImageUpdateManyWithoutGameInput;
  socials?: SocialUpdateManyWithoutGameInput;
  seo?: SeoUpdateOneWithoutGameInput;
  topApp?: TopAppUpdateOneWithoutGameInput;
  importId?: ID_Input;
  created?: Float;
  link?: String;
}

export interface GameUpdateOneRequiredWithoutTopAppInput {
  create?: GameCreateWithoutTopAppInput;
  update?: GameUpdateWithoutTopAppDataInput;
  upsert?: GameUpsertWithoutTopAppInput;
  connect?: GameWhereUniqueInput;
}

export interface CategoryUpdateOneRequiredInput {
  create?: CategoryCreateInput;
  update?: CategoryUpdateDataInput;
  upsert?: CategoryUpsertNestedInput;
  connect?: CategoryWhereUniqueInput;
}

export interface GameCreateWithoutTopAppInput {
  name: String;
  category: CategoryCreateOneInput;
  excerpt?: String;
  description?: String;
  mounthslyPlayers?: Float;
  featured?: Boolean;
  genres?: GenreCreateManyInput;
  blockchains?: BlockchainCreateManyInput;
  statistics?: StatisticCreateManyWithoutGameInput;
  images?: ImageCreateManyWithoutGameInput;
  socials?: SocialCreateManyWithoutGameInput;
  seo?: SeoCreateOneWithoutGameInput;
  importId?: ID_Input;
  created?: Float;
  link?: String;
}

export interface CategoryUpdateDataInput {
  name?: String;
}

export interface TopAppCreateInput {
  game: GameCreateOneWithoutTopAppInput;
  category: CategoryCreateOneInput;
  position: Int;
  layout: TopAppLayoutType;
}

export interface CategoryUpsertNestedInput {
  update: CategoryUpdateDataInput;
  create: CategoryCreateInput;
}

export type GenreWhereUniqueInput = AtLeastOne<{
  name: String;
}>;

export interface GenreUpdateManyInput {
  create?: GenreCreateInput[] | GenreCreateInput;
  update?:
    | GenreUpdateWithWhereUniqueNestedInput[]
    | GenreUpdateWithWhereUniqueNestedInput;
  upsert?:
    | GenreUpsertWithWhereUniqueNestedInput[]
    | GenreUpsertWithWhereUniqueNestedInput;
  delete?: GenreWhereUniqueInput[] | GenreWhereUniqueInput;
  connect?: GenreWhereUniqueInput[] | GenreWhereUniqueInput;
  disconnect?: GenreWhereUniqueInput[] | GenreWhereUniqueInput;
  deleteMany?: GenreScalarWhereInput[] | GenreScalarWhereInput;
  updateMany?:
    | GenreUpdateManyWithWhereNestedInput[]
    | GenreUpdateManyWithWhereNestedInput;
}

export interface GameUpdateWithoutStatisticsDataInput {
  name?: String;
  category?: CategoryUpdateOneRequiredInput;
  excerpt?: String;
  description?: String;
  mounthslyPlayers?: Float;
  featured?: Boolean;
  genres?: GenreUpdateManyInput;
  blockchains?: BlockchainUpdateManyInput;
  images?: ImageUpdateManyWithoutGameInput;
  socials?: SocialUpdateManyWithoutGameInput;
  seo?: SeoUpdateOneWithoutGameInput;
  topApp?: TopAppUpdateOneWithoutGameInput;
  importId?: ID_Input;
  created?: Float;
  link?: String;
}

export interface GenreUpdateWithWhereUniqueNestedInput {
  where: GenreWhereUniqueInput;
  data: GenreUpdateDataInput;
}

export type ImageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GenreUpdateDataInput {
  name?: String;
}

export interface GameCreateWithoutStatisticsInput {
  name: String;
  category: CategoryCreateOneInput;
  excerpt?: String;
  description?: String;
  mounthslyPlayers?: Float;
  featured?: Boolean;
  genres?: GenreCreateManyInput;
  blockchains?: BlockchainCreateManyInput;
  images?: ImageCreateManyWithoutGameInput;
  socials?: SocialCreateManyWithoutGameInput;
  seo?: SeoCreateOneWithoutGameInput;
  topApp?: TopAppCreateOneWithoutGameInput;
  importId?: ID_Input;
  created?: Float;
  link?: String;
}

export interface GenreUpsertWithWhereUniqueNestedInput {
  where: GenreWhereUniqueInput;
  update: GenreUpdateDataInput;
  create: GenreCreateInput;
}

export type SeoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GenreScalarWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: GenreScalarWhereInput[] | GenreScalarWhereInput;
  OR?: GenreScalarWhereInput[] | GenreScalarWhereInput;
  NOT?: GenreScalarWhereInput[] | GenreScalarWhereInput;
}

export interface SocialUpdateManyMutationInput {
  link?: String;
  name?: String;
}

export interface GenreUpdateManyWithWhereNestedInput {
  where: GenreScalarWhereInput;
  data: GenreUpdateManyDataInput;
}

export interface GameUpdateWithoutSocialsDataInput {
  name?: String;
  category?: CategoryUpdateOneRequiredInput;
  excerpt?: String;
  description?: String;
  mounthslyPlayers?: Float;
  featured?: Boolean;
  genres?: GenreUpdateManyInput;
  blockchains?: BlockchainUpdateManyInput;
  statistics?: StatisticUpdateManyWithoutGameInput;
  images?: ImageUpdateManyWithoutGameInput;
  seo?: SeoUpdateOneWithoutGameInput;
  topApp?: TopAppUpdateOneWithoutGameInput;
  importId?: ID_Input;
  created?: Float;
  link?: String;
}

export interface GenreUpdateManyDataInput {
  name?: String;
}

export interface GameUpdateOneRequiredWithoutSocialsInput {
  create?: GameCreateWithoutSocialsInput;
  update?: GameUpdateWithoutSocialsDataInput;
  upsert?: GameUpsertWithoutSocialsInput;
  connect?: GameWhereUniqueInput;
}

export interface GameCreateOneWithoutSeoInput {
  create?: GameCreateWithoutSeoInput;
  connect?: GameWhereUniqueInput;
}

export interface GameCreateWithoutSocialsInput {
  name: String;
  category: CategoryCreateOneInput;
  excerpt?: String;
  description?: String;
  mounthslyPlayers?: Float;
  featured?: Boolean;
  genres?: GenreCreateManyInput;
  blockchains?: BlockchainCreateManyInput;
  statistics?: StatisticCreateManyWithoutGameInput;
  images?: ImageCreateManyWithoutGameInput;
  seo?: SeoCreateOneWithoutGameInput;
  topApp?: TopAppCreateOneWithoutGameInput;
  importId?: ID_Input;
  created?: Float;
  link?: String;
}

export interface BlockchainUpdateWithWhereUniqueNestedInput {
  where: BlockchainWhereUniqueInput;
  data: BlockchainUpdateDataInput;
}

export interface GameCreateOneWithoutSocialsInput {
  create?: GameCreateWithoutSocialsInput;
  connect?: GameWhereUniqueInput;
}

export interface BlockchainUpdateDataInput {
  name?: String;
}

export interface SeoUpdateManyMutationInput {
  keywords?: String;
  description?: String;
}

export interface BlockchainUpsertWithWhereUniqueNestedInput {
  where: BlockchainWhereUniqueInput;
  update: BlockchainUpdateDataInput;
  create: BlockchainCreateInput;
}

export interface BlockchainWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: BlockchainWhereInput[] | BlockchainWhereInput;
  OR?: BlockchainWhereInput[] | BlockchainWhereInput;
  NOT?: BlockchainWhereInput[] | BlockchainWhereInput;
}

export interface BlockchainScalarWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: BlockchainScalarWhereInput[] | BlockchainScalarWhereInput;
  OR?: BlockchainScalarWhereInput[] | BlockchainScalarWhereInput;
  NOT?: BlockchainScalarWhereInput[] | BlockchainScalarWhereInput;
}

export interface GameUpdateWithoutSeoDataInput {
  name?: String;
  category?: CategoryUpdateOneRequiredInput;
  excerpt?: String;
  description?: String;
  mounthslyPlayers?: Float;
  featured?: Boolean;
  genres?: GenreUpdateManyInput;
  blockchains?: BlockchainUpdateManyInput;
  statistics?: StatisticUpdateManyWithoutGameInput;
  images?: ImageUpdateManyWithoutGameInput;
  socials?: SocialUpdateManyWithoutGameInput;
  topApp?: TopAppUpdateOneWithoutGameInput;
  importId?: ID_Input;
  created?: Float;
  link?: String;
}

export interface BlockchainUpdateManyWithWhereNestedInput {
  where: BlockchainScalarWhereInput;
  data: BlockchainUpdateManyDataInput;
}

export interface BlockchainUpdateInput {
  name?: String;
}

export interface SeoCreateInput {
  keywords: String;
  description: String;
  game: GameCreateOneWithoutSeoInput;
}

export interface SeoUpdateInput {
  keywords?: String;
  description?: String;
  game?: GameUpdateOneRequiredWithoutSeoInput;
}

export interface ImageUpdateManyMutationInput {
  type?: String;
  link?: String;
}

export interface CategoryCreateInput {
  name: String;
}

export interface StatisticUpdateWithWhereUniqueWithoutGameInput {
  where: StatisticWhereUniqueInput;
  data: StatisticUpdateWithoutGameDataInput;
}

export interface CategoryUpdateManyMutationInput {
  name?: String;
}

export interface StatisticUpdateWithoutGameDataInput {
  timestamp?: Float;
  dailyPlayers?: Float;
  transactions?: Float;
  volume?: Float;
}

export interface CategoryCreateOneInput {
  create?: CategoryCreateInput;
  connect?: CategoryWhereUniqueInput;
}

export interface StatisticUpsertWithWhereUniqueWithoutGameInput {
  where: StatisticWhereUniqueInput;
  update: StatisticUpdateWithoutGameDataInput;
  create: StatisticCreateWithoutGameInput;
}

export interface TopAppSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TopAppWhereInput;
  AND?: TopAppSubscriptionWhereInput[] | TopAppSubscriptionWhereInput;
  OR?: TopAppSubscriptionWhereInput[] | TopAppSubscriptionWhereInput;
  NOT?: TopAppSubscriptionWhereInput[] | TopAppSubscriptionWhereInput;
}

export interface StatisticScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  timestamp?: Float;
  timestamp_not?: Float;
  timestamp_in?: Float[] | Float;
  timestamp_not_in?: Float[] | Float;
  timestamp_lt?: Float;
  timestamp_lte?: Float;
  timestamp_gt?: Float;
  timestamp_gte?: Float;
  dailyPlayers?: Float;
  dailyPlayers_not?: Float;
  dailyPlayers_in?: Float[] | Float;
  dailyPlayers_not_in?: Float[] | Float;
  dailyPlayers_lt?: Float;
  dailyPlayers_lte?: Float;
  dailyPlayers_gt?: Float;
  dailyPlayers_gte?: Float;
  transactions?: Float;
  transactions_not?: Float;
  transactions_in?: Float[] | Float;
  transactions_not_in?: Float[] | Float;
  transactions_lt?: Float;
  transactions_lte?: Float;
  transactions_gt?: Float;
  transactions_gte?: Float;
  volume?: Float;
  volume_not?: Float;
  volume_in?: Float[] | Float;
  volume_not_in?: Float[] | Float;
  volume_lt?: Float;
  volume_lte?: Float;
  volume_gt?: Float;
  volume_gte?: Float;
  AND?: StatisticScalarWhereInput[] | StatisticScalarWhereInput;
  OR?: StatisticScalarWhereInput[] | StatisticScalarWhereInput;
  NOT?: StatisticScalarWhereInput[] | StatisticScalarWhereInput;
}

export interface SeoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SeoWhereInput;
  AND?: SeoSubscriptionWhereInput[] | SeoSubscriptionWhereInput;
  OR?: SeoSubscriptionWhereInput[] | SeoSubscriptionWhereInput;
  NOT?: SeoSubscriptionWhereInput[] | SeoSubscriptionWhereInput;
}

export interface StatisticUpdateManyWithWhereNestedInput {
  where: StatisticScalarWhereInput;
  data: StatisticUpdateManyDataInput;
}

export interface StatisticWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  game?: GameWhereInput;
  timestamp?: Float;
  timestamp_not?: Float;
  timestamp_in?: Float[] | Float;
  timestamp_not_in?: Float[] | Float;
  timestamp_lt?: Float;
  timestamp_lte?: Float;
  timestamp_gt?: Float;
  timestamp_gte?: Float;
  dailyPlayers?: Float;
  dailyPlayers_not?: Float;
  dailyPlayers_in?: Float[] | Float;
  dailyPlayers_not_in?: Float[] | Float;
  dailyPlayers_lt?: Float;
  dailyPlayers_lte?: Float;
  dailyPlayers_gt?: Float;
  dailyPlayers_gte?: Float;
  transactions?: Float;
  transactions_not?: Float;
  transactions_in?: Float[] | Float;
  transactions_not_in?: Float[] | Float;
  transactions_lt?: Float;
  transactions_lte?: Float;
  transactions_gt?: Float;
  transactions_gte?: Float;
  volume?: Float;
  volume_not?: Float;
  volume_in?: Float[] | Float;
  volume_not_in?: Float[] | Float;
  volume_lt?: Float;
  volume_lte?: Float;
  volume_gt?: Float;
  volume_gte?: Float;
  AND?: StatisticWhereInput[] | StatisticWhereInput;
  OR?: StatisticWhereInput[] | StatisticWhereInput;
  NOT?: StatisticWhereInput[] | StatisticWhereInput;
}

export interface StatisticUpdateManyDataInput {
  timestamp?: Float;
  dailyPlayers?: Float;
  transactions?: Float;
  volume?: Float;
}

export interface SeoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  keywords?: String;
  keywords_not?: String;
  keywords_in?: String[] | String;
  keywords_not_in?: String[] | String;
  keywords_lt?: String;
  keywords_lte?: String;
  keywords_gt?: String;
  keywords_gte?: String;
  keywords_contains?: String;
  keywords_not_contains?: String;
  keywords_starts_with?: String;
  keywords_not_starts_with?: String;
  keywords_ends_with?: String;
  keywords_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  game?: GameWhereInput;
  AND?: SeoWhereInput[] | SeoWhereInput;
  OR?: SeoWhereInput[] | SeoWhereInput;
  NOT?: SeoWhereInput[] | SeoWhereInput;
}

export interface ImageUpdateManyWithoutGameInput {
  create?: ImageCreateWithoutGameInput[] | ImageCreateWithoutGameInput;
  delete?: ImageWhereUniqueInput[] | ImageWhereUniqueInput;
  connect?: ImageWhereUniqueInput[] | ImageWhereUniqueInput;
  disconnect?: ImageWhereUniqueInput[] | ImageWhereUniqueInput;
  update?:
    | ImageUpdateWithWhereUniqueWithoutGameInput[]
    | ImageUpdateWithWhereUniqueWithoutGameInput;
  upsert?:
    | ImageUpsertWithWhereUniqueWithoutGameInput[]
    | ImageUpsertWithWhereUniqueWithoutGameInput;
  deleteMany?: ImageScalarWhereInput[] | ImageScalarWhereInput;
  updateMany?:
    | ImageUpdateManyWithWhereNestedInput[]
    | ImageUpdateManyWithWhereNestedInput;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CategoryWhereInput;
  AND?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput;
  OR?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput;
  NOT?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput;
}

export interface ImageUpdateWithWhereUniqueWithoutGameInput {
  where: ImageWhereUniqueInput;
  data: ImageUpdateWithoutGameDataInput;
}

export interface GameUpdateWithoutTopAppDataInput {
  name?: String;
  category?: CategoryUpdateOneRequiredInput;
  excerpt?: String;
  description?: String;
  mounthslyPlayers?: Float;
  featured?: Boolean;
  genres?: GenreUpdateManyInput;
  blockchains?: BlockchainUpdateManyInput;
  statistics?: StatisticUpdateManyWithoutGameInput;
  images?: ImageUpdateManyWithoutGameInput;
  socials?: SocialUpdateManyWithoutGameInput;
  seo?: SeoUpdateOneWithoutGameInput;
  importId?: ID_Input;
  created?: Float;
  link?: String;
}

export interface ImageUpdateWithoutGameDataInput {
  type?: String;
  link?: String;
}

export interface GameCreateOneWithoutTopAppInput {
  create?: GameCreateWithoutTopAppInput;
  connect?: GameWhereUniqueInput;
}

export interface ImageUpsertWithWhereUniqueWithoutGameInput {
  where: ImageWhereUniqueInput;
  update: ImageUpdateWithoutGameDataInput;
  create: ImageCreateWithoutGameInput;
}

export interface GameUpsertWithoutStatisticsInput {
  update: GameUpdateWithoutStatisticsDataInput;
  create: GameCreateWithoutStatisticsInput;
}

export interface ImageScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  link?: String;
  link_not?: String;
  link_in?: String[] | String;
  link_not_in?: String[] | String;
  link_lt?: String;
  link_lte?: String;
  link_gt?: String;
  link_gte?: String;
  link_contains?: String;
  link_not_contains?: String;
  link_starts_with?: String;
  link_not_starts_with?: String;
  link_ends_with?: String;
  link_not_ends_with?: String;
  AND?: ImageScalarWhereInput[] | ImageScalarWhereInput;
  OR?: ImageScalarWhereInput[] | ImageScalarWhereInput;
  NOT?: ImageScalarWhereInput[] | ImageScalarWhereInput;
}

export interface StatisticUpdateInput {
  game?: GameUpdateOneRequiredWithoutStatisticsInput;
  timestamp?: Float;
  dailyPlayers?: Float;
  transactions?: Float;
  volume?: Float;
}

export interface ImageUpdateManyWithWhereNestedInput {
  where: ImageScalarWhereInput;
  data: ImageUpdateManyDataInput;
}

export interface StatisticCreateInput {
  game: GameCreateOneWithoutStatisticsInput;
  timestamp: Float;
  dailyPlayers: Float;
  transactions: Float;
  volume: Float;
}

export interface ImageUpdateManyDataInput {
  type?: String;
  link?: String;
}

export type SocialWhereUniqueInput = AtLeastOne<{
  link: String;
}>;

export interface SocialUpdateManyWithoutGameInput {
  create?: SocialCreateWithoutGameInput[] | SocialCreateWithoutGameInput;
  delete?: SocialWhereUniqueInput[] | SocialWhereUniqueInput;
  connect?: SocialWhereUniqueInput[] | SocialWhereUniqueInput;
  disconnect?: SocialWhereUniqueInput[] | SocialWhereUniqueInput;
  update?:
    | SocialUpdateWithWhereUniqueWithoutGameInput[]
    | SocialUpdateWithWhereUniqueWithoutGameInput;
  upsert?:
    | SocialUpsertWithWhereUniqueWithoutGameInput[]
    | SocialUpsertWithWhereUniqueWithoutGameInput;
  deleteMany?: SocialScalarWhereInput[] | SocialScalarWhereInput;
  updateMany?:
    | SocialUpdateManyWithWhereNestedInput[]
    | SocialUpdateManyWithWhereNestedInput;
}

export type StatisticWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SocialUpdateWithWhereUniqueWithoutGameInput {
  where: SocialWhereUniqueInput;
  data: SocialUpdateWithoutGameDataInput;
}

export type TopAppWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SocialUpdateWithoutGameDataInput {
  link?: String;
  name?: String;
}

export interface GameUpdateOneRequiredWithoutSeoInput {
  create?: GameCreateWithoutSeoInput;
  update?: GameUpdateWithoutSeoDataInput;
  upsert?: GameUpsertWithoutSeoInput;
  connect?: GameWhereUniqueInput;
}

export interface SocialUpsertWithWhereUniqueWithoutGameInput {
  where: SocialWhereUniqueInput;
  update: SocialUpdateWithoutGameDataInput;
  create: SocialCreateWithoutGameInput;
}

export interface BlockchainUpdateManyMutationInput {
  name?: String;
}

export interface SocialScalarWhereInput {
  link?: String;
  link_not?: String;
  link_in?: String[] | String;
  link_not_in?: String[] | String;
  link_lt?: String;
  link_lte?: String;
  link_gt?: String;
  link_gte?: String;
  link_contains?: String;
  link_not_contains?: String;
  link_starts_with?: String;
  link_not_starts_with?: String;
  link_ends_with?: String;
  link_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: SocialScalarWhereInput[] | SocialScalarWhereInput;
  OR?: SocialScalarWhereInput[] | SocialScalarWhereInput;
  NOT?: SocialScalarWhereInput[] | SocialScalarWhereInput;
}

export interface CategoryUpdateInput {
  name?: String;
}

export interface SocialUpdateManyWithWhereNestedInput {
  where: SocialScalarWhereInput;
  data: SocialUpdateManyDataInput;
}

export interface GenreCreateManyInput {
  create?: GenreCreateInput[] | GenreCreateInput;
  connect?: GenreWhereUniqueInput[] | GenreWhereUniqueInput;
}

export interface SocialUpdateManyDataInput {
  link?: String;
  name?: String;
}

export type CategoryWhereUniqueInput = AtLeastOne<{
  name: String;
}>;

export interface SeoUpdateOneWithoutGameInput {
  create?: SeoCreateWithoutGameInput;
  update?: SeoUpdateWithoutGameDataInput;
  upsert?: SeoUpsertWithoutGameInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: SeoWhereUniqueInput;
}

export interface GenreSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GenreWhereInput;
  AND?: GenreSubscriptionWhereInput[] | GenreSubscriptionWhereInput;
  OR?: GenreSubscriptionWhereInput[] | GenreSubscriptionWhereInput;
  NOT?: GenreSubscriptionWhereInput[] | GenreSubscriptionWhereInput;
}

export interface SeoUpdateWithoutGameDataInput {
  keywords?: String;
  description?: String;
}

export interface TopAppUpdateInput {
  game?: GameUpdateOneRequiredWithoutTopAppInput;
  category?: CategoryUpdateOneRequiredInput;
  position?: Int;
  layout?: TopAppLayoutType;
}

export interface SeoUpsertWithoutGameInput {
  update: SeoUpdateWithoutGameDataInput;
  create: SeoCreateWithoutGameInput;
}

export interface GameUpdateOneRequiredWithoutStatisticsInput {
  create?: GameCreateWithoutStatisticsInput;
  update?: GameUpdateWithoutStatisticsDataInput;
  upsert?: GameUpsertWithoutStatisticsInput;
  connect?: GameWhereUniqueInput;
}

export interface TopAppUpdateOneWithoutGameInput {
  create?: TopAppCreateWithoutGameInput;
  update?: TopAppUpdateWithoutGameDataInput;
  upsert?: TopAppUpsertWithoutGameInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: TopAppWhereUniqueInput;
}

export interface GameUpsertWithoutSocialsInput {
  update: GameUpdateWithoutSocialsDataInput;
  create: GameCreateWithoutSocialsInput;
}

export interface TopAppUpdateWithoutGameDataInput {
  category?: CategoryUpdateOneRequiredInput;
  position?: Int;
  layout?: TopAppLayoutType;
}

export interface SocialCreateInput {
  game: GameCreateOneWithoutSocialsInput;
  link: String;
  name: String;
}

export interface TopAppUpsertWithoutGameInput {
  update: TopAppUpdateWithoutGameDataInput;
  create: TopAppCreateWithoutGameInput;
}

export interface BlockchainCreateInput {
  name: String;
}

export interface GameUpdateManyMutationInput {
  name?: String;
  excerpt?: String;
  description?: String;
  mounthslyPlayers?: Float;
  featured?: Boolean;
  importId?: ID_Input;
  created?: Float;
  link?: String;
}

export interface GameCreateInput {
  name: String;
  category: CategoryCreateOneInput;
  excerpt?: String;
  description?: String;
  mounthslyPlayers?: Float;
  featured?: Boolean;
  genres?: GenreCreateManyInput;
  blockchains?: BlockchainCreateManyInput;
  statistics?: StatisticCreateManyWithoutGameInput;
  images?: ImageCreateManyWithoutGameInput;
  socials?: SocialCreateManyWithoutGameInput;
  seo?: SeoCreateOneWithoutGameInput;
  topApp?: TopAppCreateOneWithoutGameInput;
  importId?: ID_Input;
  created?: Float;
  link?: String;
}

export interface GenreUpdateInput {
  name?: String;
}

export interface ImageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  game?: GameWhereInput;
  link?: String;
  link_not?: String;
  link_in?: String[] | String;
  link_not_in?: String[] | String;
  link_lt?: String;
  link_lte?: String;
  link_gt?: String;
  link_gte?: String;
  link_contains?: String;
  link_not_contains?: String;
  link_starts_with?: String;
  link_not_starts_with?: String;
  link_ends_with?: String;
  link_not_ends_with?: String;
  AND?: ImageWhereInput[] | ImageWhereInput;
  OR?: ImageWhereInput[] | ImageWhereInput;
  NOT?: ImageWhereInput[] | ImageWhereInput;
}

export interface GenreUpdateManyMutationInput {
  name?: String;
}

export interface StatisticUpdateManyMutationInput {
  timestamp?: Float;
  dailyPlayers?: Float;
  transactions?: Float;
  volume?: Float;
}

export interface ImageCreateInput {
  type: String;
  game: GameCreateOneWithoutImagesInput;
  link: String;
}

export interface SocialUpdateInput {
  game?: GameUpdateOneRequiredWithoutSocialsInput;
  link?: String;
  name?: String;
}

export interface GameCreateOneWithoutImagesInput {
  create?: GameCreateWithoutImagesInput;
  connect?: GameWhereUniqueInput;
}

export interface GameCreateWithoutSeoInput {
  name: String;
  category: CategoryCreateOneInput;
  excerpt?: String;
  description?: String;
  mounthslyPlayers?: Float;
  featured?: Boolean;
  genres?: GenreCreateManyInput;
  blockchains?: BlockchainCreateManyInput;
  statistics?: StatisticCreateManyWithoutGameInput;
  images?: ImageCreateManyWithoutGameInput;
  socials?: SocialCreateManyWithoutGameInput;
  topApp?: TopAppCreateOneWithoutGameInput;
  importId?: ID_Input;
  created?: Float;
  link?: String;
}

export interface GameUpdateWithoutImagesDataInput {
  name?: String;
  category?: CategoryUpdateOneRequiredInput;
  excerpt?: String;
  description?: String;
  mounthslyPlayers?: Float;
  featured?: Boolean;
  genres?: GenreUpdateManyInput;
  blockchains?: BlockchainUpdateManyInput;
  statistics?: StatisticUpdateManyWithoutGameInput;
  socials?: SocialUpdateManyWithoutGameInput;
  seo?: SeoUpdateOneWithoutGameInput;
  topApp?: TopAppUpdateOneWithoutGameInput;
  importId?: ID_Input;
  created?: Float;
  link?: String;
}

export interface GameUpdateOneRequiredWithoutImagesInput {
  create?: GameCreateWithoutImagesInput;
  update?: GameUpdateWithoutImagesDataInput;
  upsert?: GameUpsertWithoutImagesInput;
  connect?: GameWhereUniqueInput;
}

export interface ImageUpdateInput {
  type?: String;
  game?: GameUpdateOneRequiredWithoutImagesInput;
  link?: String;
}

export interface GameCreateWithoutImagesInput {
  name: String;
  category: CategoryCreateOneInput;
  excerpt?: String;
  description?: String;
  mounthslyPlayers?: Float;
  featured?: Boolean;
  genres?: GenreCreateManyInput;
  blockchains?: BlockchainCreateManyInput;
  statistics?: StatisticCreateManyWithoutGameInput;
  socials?: SocialCreateManyWithoutGameInput;
  seo?: SeoCreateOneWithoutGameInput;
  topApp?: TopAppCreateOneWithoutGameInput;
  importId?: ID_Input;
  created?: Float;
  link?: String;
}

export interface StatisticSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StatisticWhereInput;
  AND?: StatisticSubscriptionWhereInput[] | StatisticSubscriptionWhereInput;
  OR?: StatisticSubscriptionWhereInput[] | StatisticSubscriptionWhereInput;
  NOT?: StatisticSubscriptionWhereInput[] | StatisticSubscriptionWhereInput;
}

export interface GameUpsertWithoutSeoInput {
  update: GameUpdateWithoutSeoDataInput;
  create: GameCreateWithoutSeoInput;
}

export interface GameCreateOneWithoutStatisticsInput {
  create?: GameCreateWithoutStatisticsInput;
  connect?: GameWhereUniqueInput;
}

export interface TopAppUpdateManyMutationInput {
  position?: Int;
  layout?: TopAppLayoutType;
}

export interface NodeNode {
  id: ID_Output;
}

export interface TopAppPreviousValues {
  id: ID_Output;
  position: Int;
  layout: TopAppLayoutType;
}

export interface TopAppPreviousValuesPromise
  extends Promise<TopAppPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  position: () => Promise<Int>;
  layout: () => Promise<TopAppLayoutType>;
}

export interface TopAppPreviousValuesSubscription
  extends Promise<AsyncIterator<TopAppPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  position: () => Promise<AsyncIterator<Int>>;
  layout: () => Promise<AsyncIterator<TopAppLayoutType>>;
}

export interface Social {
  link: String;
  name: String;
}

export interface SocialPromise extends Promise<Social>, Fragmentable {
  game: <T = GamePromise>() => T;
  link: () => Promise<String>;
  name: () => Promise<String>;
}

export interface SocialSubscription
  extends Promise<AsyncIterator<Social>>,
    Fragmentable {
  game: <T = GameSubscription>() => T;
  link: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Image {
  id: ID_Output;
  type: String;
  link: String;
}

export interface ImagePromise extends Promise<Image>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  game: <T = GamePromise>() => T;
  link: () => Promise<String>;
}

export interface ImageSubscription
  extends Promise<AsyncIterator<Image>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  game: <T = GameSubscription>() => T;
  link: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StatisticSubscriptionPayload {
  mutation: MutationType;
  node: Statistic;
  updatedFields: String[];
  previousValues: StatisticPreviousValues;
}

export interface StatisticSubscriptionPayloadPromise
  extends Promise<StatisticSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StatisticPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StatisticPreviousValuesPromise>() => T;
}

export interface StatisticSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StatisticSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StatisticSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StatisticPreviousValuesSubscription>() => T;
}

export interface AggregateTopApp {
  count: Int;
}

export interface AggregateTopAppPromise
  extends Promise<AggregateTopApp>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTopAppSubscription
  extends Promise<AsyncIterator<AggregateTopApp>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TopAppEdge {
  node: TopApp;
  cursor: String;
}

export interface TopAppEdgePromise extends Promise<TopAppEdge>, Fragmentable {
  node: <T = TopAppPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TopAppEdgeSubscription
  extends Promise<AsyncIterator<TopAppEdge>>,
    Fragmentable {
  node: <T = TopAppSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TopAppConnection {
  pageInfo: PageInfo;
  edges: TopAppEdge[];
}

export interface TopAppConnectionPromise
  extends Promise<TopAppConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TopAppEdge>>() => T;
  aggregate: <T = AggregateTopAppPromise>() => T;
}

export interface TopAppConnectionSubscription
  extends Promise<AsyncIterator<TopAppConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TopAppEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTopAppSubscription>() => T;
}

export interface StatisticEdge {
  node: Statistic;
  cursor: String;
}

export interface StatisticEdgePromise
  extends Promise<StatisticEdge>,
    Fragmentable {
  node: <T = StatisticPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StatisticEdgeSubscription
  extends Promise<AsyncIterator<StatisticEdge>>,
    Fragmentable {
  node: <T = StatisticSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Blockchain {
  name: String;
}

export interface BlockchainPromise extends Promise<Blockchain>, Fragmentable {
  name: () => Promise<String>;
}

export interface BlockchainSubscription
  extends Promise<AsyncIterator<Blockchain>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSocial {
  count: Int;
}

export interface AggregateSocialPromise
  extends Promise<AggregateSocial>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSocialSubscription
  extends Promise<AsyncIterator<AggregateSocial>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BlockchainSubscriptionPayload {
  mutation: MutationType;
  node: Blockchain;
  updatedFields: String[];
  previousValues: BlockchainPreviousValues;
}

export interface BlockchainSubscriptionPayloadPromise
  extends Promise<BlockchainSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BlockchainPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BlockchainPreviousValuesPromise>() => T;
}

export interface BlockchainSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BlockchainSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BlockchainSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BlockchainPreviousValuesSubscription>() => T;
}

export interface SocialConnection {
  pageInfo: PageInfo;
  edges: SocialEdge[];
}

export interface SocialConnectionPromise
  extends Promise<SocialConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SocialEdge>>() => T;
  aggregate: <T = AggregateSocialPromise>() => T;
}

export interface SocialConnectionSubscription
  extends Promise<AsyncIterator<SocialConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SocialEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSocialSubscription>() => T;
}

export interface BlockchainPreviousValues {
  name: String;
}

export interface BlockchainPreviousValuesPromise
  extends Promise<BlockchainPreviousValues>,
    Fragmentable {
  name: () => Promise<String>;
}

export interface BlockchainPreviousValuesSubscription
  extends Promise<AsyncIterator<BlockchainPreviousValues>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
}

export interface SeoEdge {
  node: Seo;
  cursor: String;
}

export interface SeoEdgePromise extends Promise<SeoEdge>, Fragmentable {
  node: <T = SeoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SeoEdgeSubscription
  extends Promise<AsyncIterator<SeoEdge>>,
    Fragmentable {
  node: <T = SeoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Statistic {
  id: ID_Output;
  timestamp: Float;
  dailyPlayers: Float;
  transactions: Float;
  volume: Float;
}

export interface StatisticPromise extends Promise<Statistic>, Fragmentable {
  id: () => Promise<ID_Output>;
  game: <T = GamePromise>() => T;
  timestamp: () => Promise<Float>;
  dailyPlayers: () => Promise<Float>;
  transactions: () => Promise<Float>;
  volume: () => Promise<Float>;
}

export interface StatisticSubscription
  extends Promise<AsyncIterator<Statistic>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  game: <T = GameSubscription>() => T;
  timestamp: () => Promise<AsyncIterator<Float>>;
  dailyPlayers: () => Promise<AsyncIterator<Float>>;
  transactions: () => Promise<AsyncIterator<Float>>;
  volume: () => Promise<AsyncIterator<Float>>;
}

export interface TopAppSubscriptionPayload {
  mutation: MutationType;
  node: TopApp;
  updatedFields: String[];
  previousValues: TopAppPreviousValues;
}

export interface TopAppSubscriptionPayloadPromise
  extends Promise<TopAppSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TopAppPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TopAppPreviousValuesPromise>() => T;
}

export interface TopAppSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TopAppSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TopAppSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TopAppPreviousValuesSubscription>() => T;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface ImageEdge {
  node: Image;
  cursor: String;
}

export interface ImageEdgePromise extends Promise<ImageEdge>, Fragmentable {
  node: <T = ImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ImageEdgeSubscription
  extends Promise<AsyncIterator<ImageEdge>>,
    Fragmentable {
  node: <T = ImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CategoryPreviousValues {
  name: String;
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  name: () => Promise<String>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGenre {
  count: Int;
}

export interface AggregateGenrePromise
  extends Promise<AggregateGenre>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGenreSubscription
  extends Promise<AsyncIterator<AggregateGenre>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BlockchainEdge {
  node: Blockchain;
  cursor: String;
}

export interface BlockchainEdgePromise
  extends Promise<BlockchainEdge>,
    Fragmentable {
  node: <T = BlockchainPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BlockchainEdgeSubscription
  extends Promise<AsyncIterator<BlockchainEdge>>,
    Fragmentable {
  node: <T = BlockchainSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GenreConnection {
  pageInfo: PageInfo;
  edges: GenreEdge[];
}

export interface GenreConnectionPromise
  extends Promise<GenreConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GenreEdge>>() => T;
  aggregate: <T = AggregateGenrePromise>() => T;
}

export interface GenreConnectionSubscription
  extends Promise<AsyncIterator<GenreConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GenreEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGenreSubscription>() => T;
}

export interface GameSubscriptionPayload {
  mutation: MutationType;
  node: Game;
  updatedFields: String[];
  previousValues: GamePreviousValues;
}

export interface GameSubscriptionPayloadPromise
  extends Promise<GameSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamePreviousValuesPromise>() => T;
}

export interface GameSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GameSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GameSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamePreviousValuesSubscription>() => T;
}

export interface GameEdge {
  node: Game;
  cursor: String;
}

export interface GameEdgePromise extends Promise<GameEdge>, Fragmentable {
  node: <T = GamePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GameEdgeSubscription
  extends Promise<AsyncIterator<GameEdge>>,
    Fragmentable {
  node: <T = GameSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GamePreviousValues {
  id: ID_Output;
  name: String;
  excerpt?: String;
  description?: String;
  mounthslyPlayers?: Float;
  featured?: Boolean;
  importId?: ID_Output;
  created?: Float;
  link?: String;
}

export interface GamePreviousValuesPromise
  extends Promise<GamePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  excerpt: () => Promise<String>;
  description: () => Promise<String>;
  mounthslyPlayers: () => Promise<Float>;
  featured: () => Promise<Boolean>;
  importId: () => Promise<ID_Output>;
  created: () => Promise<Float>;
  link: () => Promise<String>;
}

export interface GamePreviousValuesSubscription
  extends Promise<AsyncIterator<GamePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  excerpt: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  mounthslyPlayers: () => Promise<AsyncIterator<Float>>;
  featured: () => Promise<AsyncIterator<Boolean>>;
  importId: () => Promise<AsyncIterator<ID_Output>>;
  created: () => Promise<AsyncIterator<Float>>;
  link: () => Promise<AsyncIterator<String>>;
}

export interface BlockchainConnection {
  pageInfo: PageInfo;
  edges: BlockchainEdge[];
}

export interface BlockchainConnectionPromise
  extends Promise<BlockchainConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BlockchainEdge>>() => T;
  aggregate: <T = AggregateBlockchainPromise>() => T;
}

export interface BlockchainConnectionSubscription
  extends Promise<AsyncIterator<BlockchainConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BlockchainEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBlockchainSubscription>() => T;
}

export interface AggregateBlockchain {
  count: Int;
}

export interface AggregateBlockchainPromise
  extends Promise<AggregateBlockchain>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBlockchainSubscription
  extends Promise<AsyncIterator<AggregateBlockchain>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Seo {
  id: ID_Output;
  keywords: String;
  description: String;
}

export interface SeoPromise extends Promise<Seo>, Fragmentable {
  id: () => Promise<ID_Output>;
  keywords: () => Promise<String>;
  description: () => Promise<String>;
  game: <T = GamePromise>() => T;
}

export interface SeoSubscription
  extends Promise<AsyncIterator<Seo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  keywords: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  game: <T = GameSubscription>() => T;
}

export interface GenreSubscriptionPayload {
  mutation: MutationType;
  node: Genre;
  updatedFields: String[];
  previousValues: GenrePreviousValues;
}

export interface GenreSubscriptionPayloadPromise
  extends Promise<GenreSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GenrePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GenrePreviousValuesPromise>() => T;
}

export interface GenreSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GenreSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GenreSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GenrePreviousValuesSubscription>() => T;
}

export interface AggregateStatistic {
  count: Int;
}

export interface AggregateStatisticPromise
  extends Promise<AggregateStatistic>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStatisticSubscription
  extends Promise<AsyncIterator<AggregateStatistic>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GenrePreviousValues {
  name: String;
}

export interface GenrePreviousValuesPromise
  extends Promise<GenrePreviousValues>,
    Fragmentable {
  name: () => Promise<String>;
}

export interface GenrePreviousValuesSubscription
  extends Promise<AsyncIterator<GenrePreviousValues>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
}

export interface SocialEdge {
  node: Social;
  cursor: String;
}

export interface SocialEdgePromise extends Promise<SocialEdge>, Fragmentable {
  node: <T = SocialPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SocialEdgeSubscription
  extends Promise<AsyncIterator<SocialEdge>>,
    Fragmentable {
  node: <T = SocialSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Genre {
  name: String;
}

export interface GenrePromise extends Promise<Genre>, Fragmentable {
  name: () => Promise<String>;
}

export interface GenreSubscription
  extends Promise<AsyncIterator<Genre>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
}

export interface SeoConnection {
  pageInfo: PageInfo;
  edges: SeoEdge[];
}

export interface SeoConnectionPromise
  extends Promise<SeoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SeoEdge>>() => T;
  aggregate: <T = AggregateSeoPromise>() => T;
}

export interface SeoConnectionSubscription
  extends Promise<AsyncIterator<SeoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SeoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSeoSubscription>() => T;
}

export interface ImageSubscriptionPayload {
  mutation: MutationType;
  node: Image;
  updatedFields: String[];
  previousValues: ImagePreviousValues;
}

export interface ImageSubscriptionPayloadPromise
  extends Promise<ImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ImagePreviousValuesPromise>() => T;
}

export interface ImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ImagePreviousValuesSubscription>() => T;
}

export interface ImageConnection {
  pageInfo: PageInfo;
  edges: ImageEdge[];
}

export interface ImageConnectionPromise
  extends Promise<ImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ImageEdge>>() => T;
  aggregate: <T = AggregateImagePromise>() => T;
}

export interface ImageConnectionSubscription
  extends Promise<AsyncIterator<ImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateImageSubscription>() => T;
}

export interface ImagePreviousValues {
  id: ID_Output;
  type: String;
  link: String;
}

export interface ImagePreviousValuesPromise
  extends Promise<ImagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  link: () => Promise<String>;
}

export interface ImagePreviousValuesSubscription
  extends Promise<AsyncIterator<ImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGame {
  count: Int;
}

export interface AggregateGamePromise
  extends Promise<AggregateGame>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGameSubscription
  extends Promise<AsyncIterator<AggregateGame>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StatisticPreviousValues {
  id: ID_Output;
  timestamp: Float;
  dailyPlayers: Float;
  transactions: Float;
  volume: Float;
}

export interface StatisticPreviousValuesPromise
  extends Promise<StatisticPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  timestamp: () => Promise<Float>;
  dailyPlayers: () => Promise<Float>;
  transactions: () => Promise<Float>;
  volume: () => Promise<Float>;
}

export interface StatisticPreviousValuesSubscription
  extends Promise<AsyncIterator<StatisticPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  timestamp: () => Promise<AsyncIterator<Float>>;
  dailyPlayers: () => Promise<AsyncIterator<Float>>;
  transactions: () => Promise<AsyncIterator<Float>>;
  volume: () => Promise<AsyncIterator<Float>>;
}

export interface TopApp {
  id: ID_Output;
  position: Int;
  layout: TopAppLayoutType;
}

export interface TopAppPromise extends Promise<TopApp>, Fragmentable {
  id: () => Promise<ID_Output>;
  game: <T = GamePromise>() => T;
  category: <T = CategoryPromise>() => T;
  position: () => Promise<Int>;
  layout: () => Promise<TopAppLayoutType>;
}

export interface TopAppSubscription
  extends Promise<AsyncIterator<TopApp>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  game: <T = GameSubscription>() => T;
  category: <T = CategorySubscription>() => T;
  position: () => Promise<AsyncIterator<Int>>;
  layout: () => Promise<AsyncIterator<TopAppLayoutType>>;
}

export interface SeoSubscriptionPayload {
  mutation: MutationType;
  node: Seo;
  updatedFields: String[];
  previousValues: SeoPreviousValues;
}

export interface SeoSubscriptionPayloadPromise
  extends Promise<SeoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SeoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SeoPreviousValuesPromise>() => T;
}

export interface SeoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SeoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SeoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SeoPreviousValuesSubscription>() => T;
}

export interface StatisticConnection {
  pageInfo: PageInfo;
  edges: StatisticEdge[];
}

export interface StatisticConnectionPromise
  extends Promise<StatisticConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StatisticEdge>>() => T;
  aggregate: <T = AggregateStatisticPromise>() => T;
}

export interface StatisticConnectionSubscription
  extends Promise<AsyncIterator<StatisticConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StatisticEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStatisticSubscription>() => T;
}

export interface AggregateImage {
  count: Int;
}

export interface AggregateImagePromise
  extends Promise<AggregateImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateImageSubscription
  extends Promise<AsyncIterator<AggregateImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SocialPreviousValues {
  link: String;
  name: String;
}

export interface SocialPreviousValuesPromise
  extends Promise<SocialPreviousValues>,
    Fragmentable {
  link: () => Promise<String>;
  name: () => Promise<String>;
}

export interface SocialPreviousValuesSubscription
  extends Promise<AsyncIterator<SocialPreviousValues>>,
    Fragmentable {
  link: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SocialSubscriptionPayload {
  mutation: MutationType;
  node: Social;
  updatedFields: String[];
  previousValues: SocialPreviousValues;
}

export interface SocialSubscriptionPayloadPromise
  extends Promise<SocialSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SocialPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SocialPreviousValuesPromise>() => T;
}

export interface SocialSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SocialSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SocialSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SocialPreviousValuesSubscription>() => T;
}

export interface Game {
  id: ID_Output;
  name: String;
  excerpt?: String;
  description?: String;
  mounthslyPlayers?: Float;
  featured?: Boolean;
  importId?: ID_Output;
  created?: Float;
  link?: String;
}

export interface GamePromise extends Promise<Game>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: <T = CategoryPromise>() => T;
  excerpt: () => Promise<String>;
  description: () => Promise<String>;
  mounthslyPlayers: () => Promise<Float>;
  featured: () => Promise<Boolean>;
  genres: <T = FragmentableArray<Genre>>(args?: {
    where?: GenreWhereInput;
    orderBy?: GenreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  blockchains: <T = FragmentableArray<Blockchain>>(args?: {
    where?: BlockchainWhereInput;
    orderBy?: BlockchainOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  statistics: <T = FragmentableArray<Statistic>>(args?: {
    where?: StatisticWhereInput;
    orderBy?: StatisticOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  images: <T = FragmentableArray<Image>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  socials: <T = FragmentableArray<Social>>(args?: {
    where?: SocialWhereInput;
    orderBy?: SocialOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  seo: <T = SeoPromise>() => T;
  topApp: <T = TopAppPromise>() => T;
  importId: () => Promise<ID_Output>;
  created: () => Promise<Float>;
  link: () => Promise<String>;
}

export interface GameSubscription
  extends Promise<AsyncIterator<Game>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  category: <T = CategorySubscription>() => T;
  excerpt: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  mounthslyPlayers: () => Promise<AsyncIterator<Float>>;
  featured: () => Promise<AsyncIterator<Boolean>>;
  genres: <T = Promise<AsyncIterator<GenreSubscription>>>(args?: {
    where?: GenreWhereInput;
    orderBy?: GenreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  blockchains: <T = Promise<AsyncIterator<BlockchainSubscription>>>(args?: {
    where?: BlockchainWhereInput;
    orderBy?: BlockchainOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  statistics: <T = Promise<AsyncIterator<StatisticSubscription>>>(args?: {
    where?: StatisticWhereInput;
    orderBy?: StatisticOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  images: <T = Promise<AsyncIterator<ImageSubscription>>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  socials: <T = Promise<AsyncIterator<SocialSubscription>>>(args?: {
    where?: SocialWhereInput;
    orderBy?: SocialOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  seo: <T = SeoSubscription>() => T;
  topApp: <T = TopAppSubscription>() => T;
  importId: () => Promise<AsyncIterator<ID_Output>>;
  created: () => Promise<AsyncIterator<Float>>;
  link: () => Promise<AsyncIterator<String>>;
}

export interface SeoPreviousValues {
  id: ID_Output;
  keywords: String;
  description: String;
}

export interface SeoPreviousValuesPromise
  extends Promise<SeoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  keywords: () => Promise<String>;
  description: () => Promise<String>;
}

export interface SeoPreviousValuesSubscription
  extends Promise<AsyncIterator<SeoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  keywords: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface GenreEdge {
  node: Genre;
  cursor: String;
}

export interface GenreEdgePromise extends Promise<GenreEdge>, Fragmentable {
  node: <T = GenrePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GenreEdgeSubscription
  extends Promise<AsyncIterator<GenreEdge>>,
    Fragmentable {
  node: <T = GenreSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSeo {
  count: Int;
}

export interface AggregateSeoPromise
  extends Promise<AggregateSeo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSeoSubscription
  extends Promise<AsyncIterator<AggregateSeo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Category {
  name: String;
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  name: () => Promise<String>;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
}

export interface GameConnection {
  pageInfo: PageInfo;
  edges: GameEdge[];
}

export interface GameConnectionPromise
  extends Promise<GameConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GameEdge>>() => T;
  aggregate: <T = AggregateGamePromise>() => T;
}

export interface GameConnectionSubscription
  extends Promise<AsyncIterator<GameConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GameEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGameSubscription>() => T;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Blockchain",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "Game",
    embedded: false
  },
  {
    name: "Genre",
    embedded: false
  },
  {
    name: "Image",
    embedded: false
  },
  {
    name: "Seo",
    embedded: false
  },
  {
    name: "Social",
    embedded: false
  },
  {
    name: "Statistic",
    embedded: false
  },
  {
    name: "TopApp",
    embedded: false
  },
  {
    name: "TopAppLayoutType",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: process.env.PRISMA_ENDPOINT
});
export const prisma = new Prisma();
